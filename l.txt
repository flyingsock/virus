import sys (60)
from collections import deque, defaultdict

def solve(edges: list[tuple[str, str]]) -> list[str]:
    edges = [(u.strip(), v.strip()) for u, v in edges]
    graph = defaultdict(set)
    for u, v in edges:
        graph[u].add(v)
        graph[v].add(u)

    gates = {n for n in graph if n.isupper()}
    virus = 'a'
    result = []

    while True:
        # Get all gate links
        candidates = []
        for gate in gates:
            for nb in graph[gate]:
                if not nb.isupper():
                    candidates.append((gate, nb))
        if not candidates:
            break

        # BFS from virus
        dist = {virus: 0}
        q = deque([virus])
        while q:
            u = q.popleft()
            for v in graph[u]:
                if v not in dist:
                    dist[v] = dist[u] + 1
                    q.append(v)

        # Find gates at distance 1
        threat = []
        for gate in gates:
            if gate in dist and dist[gate] == 1:
                threat.append(gate)

        if threat:
            threat.sort()
            gate = threat[0]
        else:
            candidates.sort()
            gate = candidates[0][0]

        # Cut lex smallest link from gate
        links = [nb for nb in graph[gate] if not nb.isupper()]
        if not links:
            break
        links.sort()
        node = links[0]
        result.append(f"{gate}-{node}")
        graph[gate].discard(node)
        graph[node].discard(gate)

        # Move virus
        dist = {virus: 0}
        q = deque([virus])
        while q:
            u = q.popleft()
            for v in graph[u]:
                if v not in dist:
                    dist[v] = dist[u] + 1
                    q.append(v)

        reachable_gates = {g: dist[g] for g in gates if g in dist}
        if not reachable_gates:
            break
        min_d = min(reachable_gates.values())
        target = min(g for g, d in reachable_gates.items() if d == min_d)

        dist_gate = {target: 0}
        q = deque([target])
        while q:
            u = q.popleft()
            for v in graph[u]:
                if v not in dist_gate:
                    dist_gate[v] = dist_gate[u] + 1
                    q.append(v)

        next_v = None
        for nb in graph[virus]:
            if nb.isupper():
                continue
            if dist_gate.get(nb, -1) == dist_gate.get(virus, -2) - 1:
                if next_v is None or nb < next_v:
                    next_v = nb
        if next_v is None:
            break
        virus = next_v

    return result

def main():
    edges = []
    for line in sys.stdin:
        line = line.strip()
        if line:
            parts = line.split('-')
            if len(parts) == 2:
                edges.append((parts[0], parts[1]))
    result = solve(edges)
    for r in result:
        print(r)

if __name__ == "__main__":
    main()

   (60)
import sys
from collections import deque, defaultdict


def solve(edges: list[tuple[str, str]]) -> list[str]:
    edges = [(u.strip(), v.strip()) for u, v in edges]

    graph = defaultdict(set)
    for u, v in edges:
        graph[u].add(v)
        graph[v].add(u)

    gates = {node for node in graph if node.isupper()}
    virus = 'a'
    result = []

    while True:
        # BFS от вируса
        dist = {virus: 0}
        q = deque([virus])
        while q:
            u = q.popleft()
            for v in graph[u]:
                if v not in dist:
                    dist[v] = dist[u] + 1
                    q.append(v)

        # Собираем шлюзы с их d и r
        gate_info = []
        for gate in gates:
            if gate in dist:
                d = dist[gate]
                r = sum(1 for nb in graph[gate] if not nb.isupper())
                if r > 0:
                    gate_info.append((gate, d, r))

        if not gate_info:
            break

        # Ищем шлюзы с d == 1 (немедленная угроза)
        imminent = [(g, d, r) for g, d, r in gate_info if d == 1]

        if imminent:
            # Выбираем лексикографически наименьший шлюз
            imminent.sort(key=lambda x: x[0])
            gate = imminent[0][0]
        else:
            # Нет угрозы — выбираем лексикографически наименьший шлюз вообще
            gate_info.sort(key=lambda x: x[0])
            gate = gate_info[0][0]

        # Отключаем лексикографически наименьший коридор от этого шлюза
        neighbors = [nb for nb in graph[gate] if not nb.isupper()]
        if not neighbors:
            break
        neighbors.sort()
        node = neighbors[0]
        result.append(f"{gate}-{node}")
        graph[gate].discard(node)
        graph[node].discard(gate)

        # Теперь — ход вируса (по его правилам)
        # Найдем цель: ближайший шлюз (даже если мы только что отключили коридор)
        reachable_gates = {g: dist[g] for g in gates if g in dist}
        if not reachable_gates:
            break
        min_d = min(reachable_gates.values())
        target_gate = min(g for g, d in reachable_gates.items() if d == min_d)

        # BFS от target_gate
        dist_gate = {target_gate: 0}
        q = deque([target_gate])
        while q:
            u = q.popleft()
            for v in graph[u]:
                if v not in dist_gate:
                    dist_gate[v] = dist_gate[u] + 1
                    q.append(v)

        next_virus = None
        current_d = dist_gate.get(virus, float('inf'))
        for nb in graph[virus]:
            if nb.isupper():
                continue
            if dist_gate.get(nb, float('inf')) == current_d - 1:
                if next_virus is None or nb < next_virus:
                    next_virus = nb

        if next_virus is None:
            break
        virus = next_virus

    return result


def main():
    edges = []
    for line in sys.stdin:
        line = line.strip()
        if line:
            node1, sep, node2 = line.partition('-')
            if sep:
                edges.append((node1, node2))
    result = solve(edges)
    for edge in result:
        print(edge)


if __name__ == "__main__":
    main()

    (60)
import sys
from collections import deque, defaultdict

def solve(edges: list[tuple[str, str]]) -> list[str]:
    # Убираем пробелы
    edges = [(u.strip(), v.strip()) for u, v in edges]

    # Строим граф
    graph = defaultdict(set)
    for u, v in edges:
        graph[u].add(v)
        graph[v].add(u)

    # Находим все шлюзы
    gates = {node for node in graph if node.isupper()}
    virus = 'a'
    result = []

    while True:
        # === Шаг 1: найти текущую цель вируса ===
        # BFS от вируса
        dist_from_virus = {virus: 0}
        queue = deque([virus])
        while queue:
            u = queue.popleft()
            for v in graph[u]:
                if v not in dist_from_virus:
                    dist_from_virus[v] = dist_from_virus[u] + 1
                    queue.append(v)

        # Достижимые шлюзы
        reachable_gates = {}
        for gate in gates:
            if gate in dist_from_virus:
                reachable_gates[gate] = dist_from_virus[gate]

        if not reachable_gates:
            break  # вирус изолирован

        # Ближайшие шлюзы
        min_dist = min(reachable_gates.values())
        closest_gates = [g for g, d in reachable_gates.items() if d == min_dist]
        target_gate = min(closest_gates)  # лексикографически наименьший

        # === Шаг 2: отключить лексикографически наименьший коридор от target_gate ===
        neighbors = []
        for nb in graph[target_gate]:
            if not nb.isupper():  # только обычные узлы
                neighbors.append(nb)

        if not neighbors:
            # Шлюз уже отключён — двигаем вирус и продолжаем
            pass
        else:
            neighbors.sort()
            node = neighbors[0]
            result.append(f"{target_gate}-{node}")
            # Отключаем коридор
            graph[target_gate].discard(node)
            graph[node].discard(target_gate)

        # === Шаг 3: вирус делает ход ===
        # BFS от target_gate (в обновлённом графе)
        dist_from_gate = {target_gate: 0}
        queue = deque([target_gate])
        while queue:
            u = queue.popleft()
            for v in graph[u]:
                if v not in dist_from_gate:
                    dist_from_gate[v] = dist_from_gate[u] + 1
                    queue.append(v)

        # Находим соседей вируса, ведущих к target_gate
        next_candidates = []
        current_dist = dist_from_gate.get(virus, float('inf'))
        for nb in graph[virus]:
            if nb.isupper():
                continue  # вирус не ходит в шлюзы
            if dist_from_gate.get(nb, float('inf')) == current_dist - 1:
                next_candidates.append(nb)

        if not next_candidates:
            break
        next_virus = min(next_candidates)
        virus = next_virus

    return result

def main():
    edges = []
    for line in sys.stdin:
        line = line.strip()
        if line:
            node1, sep, node2 = line.partition('-')
            if sep:
                edges.append((node1, node2))
    result = solve(edges)
    for edge in result:
        print(edge)

if __name__ == "__main__":
    main()